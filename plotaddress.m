(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* Initialization *)
Needs ["JLink`"]
(* Load Java functionality *)
If[JavaLink[] === Null, InstallJava[];];
LoadJavaClass["java.net.URLEncoder"];

(* Private API key from google *)
$key = "AIzaSyBufb92UiWaK5WRqZF_PeUloidrgn4OUw8";

ToWebString[s_String] := URLEncoder`encode[s, "UTF-8"]

iapi[address_String, key_String] := 
 "https://maps.googleapis.com/maps/api/geocode/json?address=" <> 
  ToWebString[address] <> "&key=" <> key
  
api[address_String] :=
	With[{res = {"lat", "lng"} /. ("location" /. ("geometry" /. ("results" /. 
		ImportString[Import[iapi[address, $key], "String"], "JSon"])))},
		Switch[res,{{_Real, _Real}}, First@res, _, Missing["NotAvailable"]]
	]


(* Define argument processor *)
cmdlnparser[arg_] := Module[{tmp},
	If[StringContainsQ[arg,"colour="],
		clist=ToExpression[Rest[StringCases[arg, RegularExpression["\\w+"]]]];
		Return
	];
	If[StringContainsQ[arg,"legend="],
		legend=Rest[StringCases[arg, RegularExpression["\\w+"]]];
		Return;
	];
	AppendTo[flist,arg];
]
(* If ScriptCommandline is completely blank, the script is being debugged in Mathematica *)
If[Length[$ScriptCommandLine]==0,
	(* Set up a debug Command Line *)
	args={NotebookDirectory[]<>"test/address1.csv",NotebookDirectory[]<>"test/address2.csv","colour={Blue,Green}","legend={Personal,Work}"};
]

(* Parse command line *)
flist = {};
clist = {};
legend = {};
cmdlnparser /@ args;


(* Define function to read input addresses *)
readaddr[ifile_] :=
	Switch[FileExtension[ifile],
		"csv",Import[ifile],
		"xls",Import[ifile,{"data",1}],
		"xlsx",Import[ifile,{"data",1}]
	]

(* Read files from the command line *)
tblInput = readaddr /@ flist[[;;-3]];


(* Define Function to geolocate adress list *)
geoloc[input_] := Module[{colAddresses, colLocations, tmp},
	(* Merge address components into a single string *)
	colAddresses = StringJoin[Riffle[#, " "]] & /@ input;
	(* Geolocate the address on Google *)
	colLocations = api[#] & /@ colAddresses;
	(* flip the table and add the latitude and longitude as rows *)
	tmp = Transpose[input];
	tmp = Append[tmp, First@# & /@ colLocations]; 
	tmp = Append[tmp, Last@# & /@ colLocations];
	Transpose[tmp]
]

(* Geolocate Addresses from Google Maps *)
tblLoc = geoloc /@ tblInput;


(* Create a function to convert address listing to a list of geopositions *)
cvttogeopos[addrlst_]:= Module[{tmp},
	(* Filter out all addresses not located *)
	tmp = Map[addrlst, Select[addrlst, realQ[#[[All,6]]]], 2];
	(* Convert the information to a list of GeoPosition Objects *)
	GeoPosition[#]&/@ tmp[[All,{6,7}]]
]

(* build a list of position lists *)
geoPos = cvttogeopos /@ tblLoc;


(* Plot the locations *)
imgGeoPlot = GeoListPlot[geoPos,ImageSize->1920,PlotStyle->clist,PlotLegends->legend]


(* Save Graphic *)
Export["addrplot.jpg",imgGeoPlot]
