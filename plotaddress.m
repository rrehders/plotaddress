(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* Initialization *)
Needs ["JLink`"]
(* Load Java functionality *)
If[JavaLink[] === Null, InstallJava[];];
LoadJavaClass["java.net.URLEncoder"];

(* Private API key from google *)
$key = "AIzaSyBufb92UiWaK5WRqZF_PeUloidrgn4OUw8";

ToWebString[s_String] := URLEncoder`encode[s, "UTF-8"]

iapi[address_String, key_String] := 
 "https://maps.googleapis.com/maps/api/geocode/json?address=" <> 
  ToWebString[address] <> "&key=" <> key
  
api[address_String] :=
	With[{res = {"lat", "lng"} /. ("location" /. ("geometry" /. ("results" /. 
		ImportString[Import[iapi[address, $key], "String"], "JSon"])))},
		Switch[res,{{_Real, _Real}}, First@res, _, Missing["NotAvailable"]]
	]


(* Define argument processor *)
cmdlnparser[arg_] := Module[{tmp},
	If[StringContainsQ[arg,"colour="],
		clist=ToExpression[Rest[StringCases[arg, RegularExpression["\\w+"]]]];
		Return[];
	];
	If[StringContainsQ[arg,"legend="],
		legend=Rest[StringCases[arg, RegularExpression["\\w+"]]];
		Return[];
	];
	AppendTo[flist,arg];
]
args = $ScriptCommandLine;


(* If $ScriptCommandLine is completely blank, the script/notebook is being debugged in Mathematica *)
If[Length[$ScriptCommandLine]==0,
	args={"plotaddress"};
	(* Set up a debug Command Line *)
	(* AppendTo[args,NotebookDirectory[]<>"test/address1.csv"]; *)
	(* AppendTo[args,NotebookDirectory[]<>"test/address2.csv"]; *)
	(* AppendTo[args,"colour={Blue,Green}"]; *)
	(* AppendTo[args,"legend={Personal,Work}"]; *)
	(* AppendTo[args,NotebookDirectory[]<>"test/address.csv"]; *)
,
	Nothing
]


If[Length[args]==1,
	Print["USAGE: plotaddress file1 [file2...] [colour={colour1,colour2...}] [legend={title1,title2...}"]
	Exit[]
,
	Nothing
]

(* Parse command line *)
flist = {};
clist = {};
legend = {};
cmdlnparser /@ Rest[args];
Print["Command Line Parsed"]
(* Change Default plot colour to Blue *)
(* If Colour is not pecified Mathematica defaults to an orange colour *)
If[Length[clist]==0,
	clist={Blue}
,
	Nothing
]


(* Define function to read input addresses *)
readaddr[ifile_] := 
Switch[FileExtension[ifile],
	"csv",Import[ifile],
	"xls",Import[ifile,{"data",1}],
	"xlsx",Import[ifile,{"data",1}],
	_,Nothing
]

(* Read files from the command line *)
tblInput = readaddr /@ flist;


If[MemberQ[tblInput,$Failed],
	Print["One or more files specified do not exist"];
	Exit[1]
,
	Print["Input files Read"]
]



(* Define Function to geolocate adress list *)
geoloc[input_] := Module[{colAddresses, colLocations, tmp},
	(* Merge address components into a single string *)
	colAddresses = StringJoin[Riffle[#, " "]] & /@ input;
	(* Geolocate the address on Google *)
	colLocations = api[#] & /@ colAddresses;
	(* flip the table to add the latitude and longitude as rows *)
	tmp = Transpose[input];
	tmp = Append[tmp, First@# & /@ colLocations]; 
	tmp = Append[tmp, Last@# & /@ colLocations];
	(* Flip the table back to restore columnar format *)
	tmp = Transpose[tmp];
	(* Filter out any addresses not located *)
	Select[tmp,NumberQ[#[[6]]]&]
]

(* Clean Addresses in preparation for plotting *)
tblLoc = Select[tblInput,NumberQ[#[[6]]&];
Print["Address clense Complete"]


(* Convert the full nested list into a list of Goegraphic Coordinates only *) 
geoPos = Map[GeoPosition[#[[{6,7}]]]&, tblLoc, {2}];
Print["Coordinates converted to positions"]


(* Plot the locations *)
(* Use Bit operations to build 4 cases based on presence of colour and legend parameters *)
(* 0 no colour or legend specified *)
(* 1 Legends specified, but not colours *)
(* 2 Colours specified, but not Legend *)
(* 3 Both Colours and Legend Specified *)
Switch[If[Length[clist]>0,BitSet[0,1],0]+If[Length[legend]>0,BitSet[0,0],0],
	0,imgGeoPlot = GeoListPlot[geoPos,ImageSize->1920];,
	1,imgGeoPlot = GeoListPlot[geoPos,ImageSize->1920,PlotLegends->legend];,
	2,imgGeoPlot = GeoListPlot[geoPos,ImageSize->1920,PlotStyle->clist];,
	3,imgGeoPlot = GeoListPlot[geoPos,ImageSize->1920,PlotStyle->clist,PlotLegends->legend];,
	_,Nothing]
Print["Locations plotted"]


(* Save Graphic *)
Export["addrplot.jpg",imgGeoPlot]
Print["Output file created"]
